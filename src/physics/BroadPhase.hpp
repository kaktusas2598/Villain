#pragma once

#include "RigidBody.hpp"

namespace Villain {

    // Potential contact between 2 rigid bodies generated by broad collision detection phase
    struct PotentialContact {
        RigidBody* body[2];
    };

    // Binary tree used to represent Bounding Volume Hierarchy
    template <class BoundingVolumeClass>
    class BVHNode {
        public:
            // TODO: provide means for initialisation

            // Checks whether this node is at the bottom of the hierarchy
            bool isLeaf() const { return (body != nullptr); }

            // Checks the number of potential contacts from this node downward in the hierarchy writing them to array
            // (up to a given limit) and returning number of potential contacts it found
            unsigned getPotentialContacts(PotentialContact* contacts, unsigned limit) const;

        protected:
            // Checks for overlapping nodes in the hierarchy
            bool overlaps(const BVHNode<BoundingVolumeClass>* other) const;

            // Checks the potential contacts between this node and other given node
            unsigned getPotentialContactsWith(const BVHNode<BoundingVolumeClass>* other, PotentialContact* contacts, unsigned limit) const;

        private:
            BVHNode* children[2]; //< Children nodes of this node
            BoundingVolumeClass volume; //< Single bounding volume encompassing all the descendants of this node
            RigidBody* body = nullptr; //< Body at this node of the hierarchy, only leaf nodes can have rigid body defined
    };

    template <class BoundingVolumeClass>
    bool BVHNode<BoundingVolumeClass>::overlaps(const BVHNode<BoundingVolumeClass>* other) const {
        return volume->overlaps(other->volume);
    }

    template <class BoundingVolumeClass>
    unsigned BVHNode<BoundingVolumeClass>::getPotentialContacts(PotentialContact* contacts, unsigned limit) const {
        if (isLeaf() || limit == 0) return 0;

        // Get potential contacts of one of the children with the other one
        return children[0]->getPotentialContactsWith(children[1], contacts, limit);
    }

    template <class BoundingVolumeClass>
    unsigned BVHNode<BoundingVolumeClass>::getPotentialContactsWith(
            const BVHNode<BoundingVolumeClass>* other, PotentialContact* contacts, unsigned limit) const {
        if (!overlaps(other) || limit == 0) return 0;

        // If both are leaf nodes then there is potential contact
        if (isLeaf() && other->isLeaf()) {
            contacts->body[0] = body;
            contacts->body[1] = other->body;
            return 1;
        }

        // Determine which node to descend into - if either node is leaf, then descend into the other.
        // If both nodes are branches, then descend into bigger one
        if (other->isLeaf() || (!isLeaf() && volume->getSize() >= other->volume->getSize())) {
            // Recurse into self
            unsigned count = children[0]->getPotentialContactsWith(other, contacts, limit);

            // Check if there are enough slots left to check other node
            if (limit > count) {
                return count + children[1]->getPotentialContactsWith(other, contacts + count, limit - count);
            } else {
                return count;
            }
        } else {
            // Recurse into other node
            unsigned count = getPotentialContactsWith(other->children[0], contacts, limit);

            // Check if there are enough slots left to check other node
            if (limit > count) {
                return count + other->children[1]->getPotentialContactsWith(other, contacts + count, limit - count);
            } else {
                return count;
            }
        }
    }
}
