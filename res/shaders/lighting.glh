struct Material {
    vec4 ambientColor;
    vec4 diffuseColor;
    vec4 specularColor;

    float shininess;

    float dispMapScale; // To make sure we don't get too much of parallax disp
    float dispMapBias; // Or offset

    bool useDiffuseMap;
    bool useSpecularMap;
    bool useNormalMap;
    bool useDispMap;

    sampler2D texture_diffuse;
    sampler2D texture_specular;
    sampler2D texture_normal;
    sampler2D texture_disp;
};

struct PBRMaterial {
    vec3 albedo;
    float metallic;
    float roughness;
    float ao;

    bool useAlbedoMap;
    bool useMetallicMap;
    bool useNormalMap;
    bool useRoughnessMap;
    bool useAOMap;

    sampler2D texture_albedo;
    sampler2D texture_metallic;
    sampler2D texture_normal;
    sampler2D texture_roughness;
    sampler2D texture_ao;
};

struct BaseLight {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    // 2023-04-24 UPDATE: Technicaly Directional lights have no position, but we need to simulate it
    // for shadow map, so we can dynamically calculate light direction using position taken from scene node
    // 2023-08-15 UPDATE2: Moved to base light for PBR calculations for now
    vec3 position;
};

struct DirectionalLight {
    BaseLight base;

    vec3 direction;
};

struct PointLight {
    BaseLight base;

    // attenuation
    float constant;
    float linear;
    float quadratic;
};

struct SpotLight {
    BaseLight base;

    vec3 direction;
    float cutOff;
    float outerCutOff;

    // attenuation
    float constant;
    float linear;
    float quadratic;
};

uniform bool toonShadingEnabled = true;
const int toonColorLevels = 4;
const float toonScaleFactor = 1.0f / toonColorLevels;

// Simple material used with blinn phong rendering
uniform Material material;

// Including Cook-Torrance BRDF functions (geometry, fresnel and D) for PBR rendering
#include BRDF.glh
uniform PBRMaterial pbrMaterial;
uniform bool usePBR = false;

uniform sampler2D shadowMap;

// TODO: need to pass material to these methods instead of harcoding uniform here
BaseLight calculateLight(BaseLight base, vec3 normal, vec3 lightDir, vec3 viewDir, vec2 texCoords, vec3 worldPos) {

    BaseLight newLight;
    if (usePBR) {
        vec3 albedo;
        float metallic, roughness, ao;
        if (pbrMaterial.useAlbedoMap)
            albedo = texture(pbrMaterial.texture_albedo, texCoords).rgb;
            //albedo = pow(texture(pbrMaterial.texture_albedo, texCoords).rgb, vec3(2.2));
        else
            albedo = pbrMaterial.albedo;
        if (pbrMaterial.useMetallicMap)
            metallic  = texture(pbrMaterial.texture_metallic, texCoords).r;
        else
            metallic = pbrMaterial.metallic;
        if (pbrMaterial.useRoughnessMap)
            roughness  = texture(pbrMaterial.texture_roughness, texCoords).r;
        else
            roughness = pbrMaterial.roughness;
        if (pbrMaterial.useAOMap)
            ao  = texture(pbrMaterial.texture_ao, texCoords).r;
        else
            ao = pbrMaterial.ao;

        vec3 N = normal;
        vec3 V = viewDir;
        // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0
        // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)
        vec3 F0 = vec3(0.04);
        F0 = mix(F0, albedo, metallic);

        // reflectance equation
        vec3 Lo = vec3(0.0);

        // calculate per-light radiance
        //vec3 L = normalize(base.position - worldPos);
        vec3 L = lightDir;
        vec3 H = normalize(V + L);
        float distance    = length(base.position - worldPos);
        float attenuation = 1.0 / (distance * distance);
        vec3 radiance     = base.diffuse;// * attenuation;

        // cook-torrance brdf
        float NDF = DistributionGGX(N, H, roughness);
        float G   = GeometrySmith(N, V, L, roughness);
        vec3 F    = FresnelSchlick(max(dot(H, V), 0.0), F0);

        // Calculate specular component using BRDF
        vec3 numerator    = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
        vec3 specular     = numerator / denominator;

        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - metallic;

        // add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);
        Lo += (kD * albedo / PI + specular) * radiance * NdotL;

        vec3 ambient = vec3(0.03) * albedo * ao;
        vec3 newColor = ambient + Lo;

        // HDR tonemapping
        //newColor = newColor / (newColor + vec3(1.0));
        // gamma correct
        //newColor = pow(newColor, vec3(1.0/2.2));

        newLight.ambient = vec3(0.0);
        newLight.diffuse = newColor;
        newLight.specular = vec3(0.0);
    } else { // Blinn-Phong shading
        float diff = max(dot(normal, lightDir), 0.0);
        //float diff = max(dot(normal, -lightDir), 0.0);

        if (toonShadingEnabled) {
            if (diff > 0)
                diff = ceil(diff * toonColorLevels) * toonScaleFactor;
        }

        // Blinn-Phong shading addition
        vec3 halfwayDirection = normalize(lightDir + viewDir);
        float spec = pow(max(dot(normal, halfwayDirection), 0.0), material.shininess);
        // Phong
        //vec3 reflectDirection = reflect(-lightDir, normal);
        //float spec = pow(max(dot(viewDir, reflectDirection), 0.0), material.shininess);

        if (material.useSpecularMap) {
            newLight.specular = base.specular * spec * vec3(texture(material.texture_specular, texCoords));
        } else {
            newLight.specular = base.specular * spec * material.specularColor.xyz;
        }

        if (material.useDiffuseMap) {
            newLight.ambient = base.ambient * vec3(texture(material.texture_diffuse, texCoords));
            newLight.diffuse = base.diffuse * diff * vec3(texture(material.texture_diffuse, texCoords)) * material.diffuseColor.xyz;
        } else {
            newLight.ambient = base.ambient * material.ambientColor.xyz;
            newLight.diffuse = base.diffuse * diff * material.diffuseColor.xyz;
        }
    }

    return newLight;
}

vec3 calculateDirLight(DirectionalLight light, vec3 normal, vec3 fragPos, vec3 viewDirection, vec2 texCoords) {
    //vec3 lightDirection = [>v_TBN *<] normalize(-light.direction);
    //vec3 lightDirection = normalize(light.base.position - fragPos);
    vec3 lightDirection = /*v_TBN **/ normalize(-light.base.position);

    BaseLight newLight = calculateLight(light.base, normal, lightDirection, viewDirection, texCoords, fragPos);

    return (newLight.ambient + newLight.diffuse + newLight.specular);
}

vec3 calculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDirection, vec2 texCoords) {
    vec3 lightDirection = /*v_TBN **/ normalize(light.base.position - fragPos);
    // attenuation
    float distance = length(light.base.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    BaseLight newLight = calculateLight(light.base, normal, lightDirection, viewDirection, texCoords, fragPos);

    newLight.ambient *= attenuation;
    newLight.diffuse *= attenuation;
    newLight.specular *= attenuation;
    return (newLight.ambient + newLight.diffuse + newLight.specular);
}

vec3 calculateSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDirection, vec2 texCoords) {
    vec3 lightDirection = /*v_TBN **/ normalize(light.base.position - fragPos);
    float theta = dot(lightDirection, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // attenuation
    float distance = length(light.base.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    BaseLight newLight = calculateLight(light.base, normal, lightDirection, viewDirection, texCoords, fragPos);

    newLight.ambient *= attenuation;
    newLight.diffuse *= attenuation;
    newLight.specular *= attenuation;

    newLight.diffuse *= intensity;
    newLight.specular *= intensity;
    return (newLight.ambient + newLight.diffuse + newLight.specular);
}
